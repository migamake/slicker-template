{-# START_FILE stack.yaml #-}
resolver: lts-13.26

packages:
  - .

allow-newer: true

extra-deps:
- shake-0.18.3
- js-dgtable-0.5.2@sha256:f75cb4fa53c88c65794becdd48eb0d3b2b8abd89a3d5c19e87af91f5225c15e4
- filepattern-0.1.1@sha256:984f43798572e325e9509b3b59fd4ccc2b0f94b8b065585e0505570c98aa1016
- extra-1.6.17@sha256:af90eeb95b08ac1683c466efd9d4b8d9d426a547eb5fa46af87f615bb67dfae0,2705
- heaps-0.3.6.1@sha256:7928b759ca5180d35722c45948c0bde264229f3c99c1888188a3d9285f13d3d2,1340
- Cabal-2.2.0.1@sha256:2a80d8fb655474f0eaeb20434c47f64f84e6302e55973056f00df8ca050b9683,20037
- fsnotify-0.3.0.1@sha256:58bb530d7acf93eb4ed69473e32a1485581815f04f69dfc8a278523781ba49dd,2988
- containers-0.5.11.0@sha256:28ad7337057442f75bc689315ab4ec7bdf5e6b2c39668f306672cecd82c02798,16685
- binary-0.8.7.0@sha256:ae3e6cca723ac55c54bbb3fa771bcf18142bc727afd57818e66d6ee6c8044f12,7705
- magic-1.1@sha256:3a31ca1c49fa5f6a857f647471739bd240a6020af6ae43e71fb72201fc482fa2,928
- git: git@github.com:ChrisPenner/slick.git
  commit: 1b1be9afb41108234211a0d781c701dde9bbf0c0
- git: git@gitlab.com:migamake/shake-watch.git
  commit: 82cce9707912b50ee03d973bcc47b0cc511b2220
- git: git@gitlab.com:migamake/slick-live.git
  commit: a563b66c10b308959808fbb44632c29577287788
- git: git@gitlab.com:migamake/slick-extra.git
  commit: 3fa920da9ac98d133ae5868ba27dae1cffda241b

{-# START_FILE package.yaml #-}
name:                {{name}}
version:             0.1.0.0
#synopsis:
#description:
homepage:            "https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme"
license:             BSD3
author:              "{{author-name}}{{^author-name}}Author name here{{/author-name}}"
maintainer:          "{{author-email}}{{^author-email}}example@example.com{{/author-email}}"
copyright:           "{{copyright}}{{^copyright}}{{year}}{{^year}}2019{{/year}} {{author-name}}{{^author-name}}Author name here{{/author-name}}{{/copyright}}"
category:            {{category}}{{^category}}Web{{/category}}

extra-source-files:
- README.md

description:         Company website <https://www.site.com>

executables:
  {{name}}:
    main:                Main.hs
    source-dirs:         app
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    - -O0
    dependencies:
    - base >= 4.7 && < 5
    - shake
    - shake-watch
    - slick
    - slick-extra
    - slick-live
    - aeson
    - extra
    - lens-aeson
    - lens
    - text
    - binary
    - containers
    - time
    - MissingH
    - hashable
    - pandoc
    - directory

{-# START_FILE Setup.hs #-}
import Distribution.Simple
main = defaultMain

{-# START_FILE app/Main.hs #-}
{-# LANGUAGE CPP                        #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DuplicateRecordFields      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE NamedFieldPuns             #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE RecordWildCards            #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TemplateHaskell            #-}

module Main where

import           Control.Applicative
import           Control.Concurrent
import           Control.Lens
import           Control.Monad                 (forM_, forever, liftM, mzero,
                                                void, when)
import           Data.Aeson                    as A
import           Data.Aeson.Lens
import           Data.Aeson.TH
import           Data.Aeson.TH                 (Options (..), defaultOptions,
                                                deriveJSON)
import           Data.Char
import           Data.Either.Utils
import           Data.Function                 (on)
import           Data.IORef
import           Data.List                     as L (intersperse, sortBy, (\\))
import           Data.Map                      as M
import           Data.Monoid
import           Data.Set                      as S
import           Data.String.Utils
import qualified Data.Text                     as T
import           Data.Text.Lens
import           Data.Time
import           Development.Shake
import           Development.Shake.Classes
import           Development.Shake.Database
import           Development.Shake.FilePath    (toStandard)
import           Development.Shake.FilePath
import           Development.Shake.Util        (shakeArgsPruneWith)
import           Development.Shake.Watch
import           Development.Shake.Watch.Types hiding (action)
import           Slick
import           Slick.Extra
import           Slick.Serve
import           System.Console.GetOpt
import           System.Directory
import           System.Directory.Extra        (listFilesRecursive, removeFile)
import           System.Environment

-- local modules
import           Builder

-------------------------------------------------------------------------------

-- | List our custom keys that we need to manage additional behaviour
data Flags =
    Preview     -- ^ key to run Warp server
 -- SomeOtherKEy
  deriving (Eq)

-- | Specific flags for Shake to allow custom keys required for specific logic
flags :: forall a. [OptDescr (Either a Flags)]
flags =
  [ Option "" ["preview"      ] (NoArg $ Right Preview    ) "running as preview"
  ]

-- | Rules for the Shake builder that define site construction workflow
--  (should live in a separate function that can be used as an argument in other functions)
buildRules :: Foldable t => t Flags -> Rules ()
buildRules flags = do
  let isPreviewMode = Preview     `elem`    flags

  action $ runAfter $ putStrLn "RUNNING AFTER!!!"
  when isPreviewMode $ do
    action $ runAfter $ liftIO $ void . forkIO $ do
      putStrLn $ "Running with Preview"
      serverStart "public" "127.0.0.1" 3030 serverHandler

  id $ do
      liftIO $ putStrLn $ "Running in Production mode\n"

      -- Set up caches
      let entitiesDir = "site"

      aboutCache         <- jsonCache' $ loadEntity myMarkdownOptions html5Options entitiesDir
      postsCache         <- jsonCache' $ loadEntity myMarkdownOptions html5Options entitiesDir

      want ["lint"]

      -- Require all the things we need to build the whole site
      phony "site" $ do
          -- Required folders and pages that should be part of output
          let reqDirectories =
               [ "static"
               , "posts"
               , "public/robots.txt"
               , "public/index.html"
               , "public/news.html"
               , "public/about.html"
               , "public/404.html"
               ]

          need reqDirectories

          pages <- fmap (("public"</>) . (-<.>"html")) <$> getDirectoryFiles "site" ["*.md"]
          liftIO $ print pages
          need pages

      "linkchecker.out" ~> do
          need ["site"]
          command_ [Cwd "public"] "linkchecker" ["--no-status", "."]

      phony "tidy" $ do
          need ["site"]
          --need ["public//index.html", "public/posts/*.html"]
          inputs <- getDirectoryFiles "public" ["//*.html"]
          forM_ inputs $ \input ->
            --liftIO $ putStrLn $ "Run tidy on " <> input
            command_ [Cwd "public"] "tidy" (["-config", "../tidy.init", input])

      -- Linting
      phony "lint" $ do
          need ["tidy", "linkchecker.out"]

      phony "static" $ do
          staticFiles <-
            getDirectoryFiles "." [ "site/css//*"
                                  , "site/js//*"
                                  , "site/fonts//*"
                                  , "site/images//*"
                                  , "site/presi//*.pdf"
                                  , "site/robots.txt"
                                  , "site/humans.txt" ]
          need (("public" </>) . dropDirectory1 <$> staticFiles)

      -- Require all static assets
      -- Rule for handling static assets, just copy them from source to dest
      [ "public/css//*",
        "public/js//*",
        "public/fonts//*",
        "public/images//*",
        "public/robots.txt",
        "public/humans.txt"
        ] |%> \out -> do
          copyFileChanged ("site" </> dropDirectory1 out) out

      -- rule for building About page
      "public/about.html" %> buildAbout aboutCache

      -- Find and require every post to be built and News page
      "posts" ~> requireEntity entitiesDir "posts" "//*.md"
      "public/posts//*.html" %> buildPost postsCache
      "public/news.html" %> buildNews postsCache

      -- build the main table of contents
      "public/*.html"     %> buildOther
      "public/index.html" %> buildIndex postsCache

  want ["site"]

-- | Function to start custom Shake pipeline for execution
--
runShakeBuilder :: ShakeOptions                     -- ^ Options for the Shake builder
                -> [OptDescr (Either String Flags)] -- ^ Converted CLI arguments
                -> IO ()
runShakeBuilder shOpts flags =
 shakeArgsPruneWith
    shOpts (pruner "public") flags $
      \flags targets -> do
        let rls = Just $ buildRules flags
        return $ rls

main :: IO ()
main = do
  shakeArgs <- getArgs
  cwd       <- getCurrentDirectory

  let shOpts  = shakeOptions {shakeVerbosity = Quiet}

  -- Run Shake pipeline as usuall
  runShakeBuilder
    shOpts
    flags

  forever $ threadDelay 100000

{-# START_FILE app/Builder.hs #-}
{-# LANGUAGE CPP                       #-}
{-# LANGUAGE DataKinds                 #-}
{-# LANGUAGE DeriveGeneric             #-}
{-# LANGUAGE DuplicateRecordFields     #-}
{-# LANGUAGE NamedFieldPuns            #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE OverloadedStrings         #-}
{-# LANGUAGE Rank2Types                #-}
{-# LANGUAGE RecordWildCards           #-}
{-# LANGUAGE ScopedTypeVariables       #-}
{-# LANGUAGE TemplateHaskell           #-}

module Builder( buildIndex
              , buildOther
              , buildNews
              , buildAbout
              , buildPost
              , myMarkdownOptions
              , html5Options
              ) where

import           Control.Applicative
import           Control.Lens
import           Control.Monad                (liftM, mzero)
import           Data.Aeson                   as A
import           Data.Aeson.Lens
import           Data.Aeson.TH
import           Data.Aeson.TH                (Options (..), defaultOptions,
                                               deriveJSON)
import           Data.Char
import           Data.Function                (on)
import           Data.List                    (intersperse, sortBy)
import           Data.Map                     as M
import           Data.Maybe
import           Data.Monoid
import           Data.Set                     as S
import           Data.String.Utils
import qualified Data.Text                    as T
import           Data.Text.Lens
import           Data.Time
import           Development.Shake
import           Development.Shake.Classes
import           Development.Shake.FilePath
import           Slick
import           Slick.Extra
import           Slick.Pandoc
import           System.Console.GetOpt
import           System.Environment
import           Text.Pandoc.Extensions
import           Text.Pandoc.Highlighting
import           Text.Pandoc.Options
import           Text.Pandoc.Readers.Markdown (readMarkdown)
import           Text.Pandoc.Writers.HTML     (writeHtml5String)

import           Types

--------------------------------------------------------------------------------
-- Page Builders

-- | Given a cache of posts this will build a table of contents
buildIndex :: (EntityFilePath PostFilePath -> Action Post)
           -> FilePath
           -> Action ()
buildIndex postCache out = do
  posts     <- traverse (postCache . EntityFilePath) =<< fileNames "site" "posts" "//*.md"
  indexTpl  <- compileTemplate' "site/templates/index.html"

  let postsSorted      = reverse $ sortBy (\p1 p2 -> compare (date p1) (date p2)) posts
      postsFeatured    = Prelude.take 5 $ catMaybes $ Prelude.map (\p -> if (featured p) then (Just p) else Nothing ) postsSorted

  let indexWrap = IndexWrap { posts         = postsSorted
                            , postsFeatured = postsFeatured
                            }
      indexHTML = T.unpack $ substitute indexTpl (toJSON indexWrap)
  writeFile' out indexHTML

-- | Builds about html page
buildAbout :: (EntityFilePath AboutFilePath -> Action About)
           -> FilePath
           -> Action ()
buildAbout  aboutCache out = do
  about'<- traverse (aboutCache . EntityFilePath) =<< fileNamesByPattern "site/about.md"
  aboutTpl  <- compileTemplate' "site/templates/about.html"

  let about''   = head about'
      aboutWrap = AboutWrap { abContent     = abrwContent about''
                            , abUrl         = abrwUrl about''
                            , abTitle       = abrwTitle about''
                            , abDescription = abrwDescription about''
                            }
      aboutHTML = T.unpack $ substitute aboutTpl (toJSON aboutWrap)

  writeFile' out aboutHTML

-- | Given a cache of posts this will build a table of contents
buildNews :: (EntityFilePath PostFilePath -> Action Post)
          -> FilePath
          -> Action ()
buildNews postCache out = do
  posts    <- traverse (postCache . EntityFilePath) =<< fileNames "site" "posts" "//*.md"
  indexTpl <- compileTemplate' "site/templates/news.html"

  let postsSorted = reverse $ sortBy (\p1 p2 -> compare (date p1) (date p2)) posts
      newsWrap    = NewsWrap
                      { news    = postsSorted
                      }
      newsHTML = T.unpack $ substitute indexTpl (toJSON newsWrap)
  writeFile' out newsHTML

-- | Build a html file for a given post from a cache of posts.
buildPost :: (EntityFilePath PostFilePath -> Action Post)
          -> FilePath
          -> Action ()
buildPost postCache out = do
  let srcPath = destToSrc "site" out -<.> "md"
      postURL = srcToURL srcPath
  post <- postCache (EntityFilePath srcPath)
  template <- compileTemplate' "site/templates/post.html"
  writeFile' out . T.unpack $ substitute template (toJSON post)

-- | Builds any other html page encountered during execution
buildOther filename = do
    liftIO $ putStrLn $ unwords ["source", show source, "template", show template]
    need [source, template]
    content  <- readFile' source >>=  markdownToHTML myMarkdownOptions html5Options . T.pack
    template <- compileTemplate' template
    writeFile' filename . T.unpack $ substitute template $ toJSON content
  where
    source   = destToSrc "site" filename -<.> "md"
    template = "site/templates/generic.html"

--------------------------------------------------------------------------------
-- Pandoc customization

myMarkdownToHTML :: T.Text -> Action Value
myMarkdownToHTML  =
  loadUsing (readMarkdown myMarkdownOptions) (writeHtml5String html5Options)

myMarkdownOptions = def { readerExtensions = exts }
 where
  exts = mconcat
    [ extensionsFromList
      [ Ext_yaml_metadata_block
      , Ext_fenced_code_attributes
      , Ext_auto_identifiers
      , Ext_inline_notes
      , Ext_multiline_tables
      ]
    , githubMarkdownExtensions
    ]

html5Options :: WriterOptions
html5Options =
  def { writerHighlightStyle = Just tango
      , writerExtensions     = writerExtensions def
      }

{-# START_FILE app/Types.hs #-}
{-# LANGUAGE CPP                   #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DeriveAnyClass        #-}
{-# LANGUAGE DeriveGeneric         #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE KindSignatures        #-}
{-# LANGUAGE NamedFieldPuns        #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TupleSections         #-}
{-# LANGUAGE TypeFamilies          #-}

module Types where

import           Control.Applicative
import           Control.Lens
import           Control.Monad              (liftM, mzero)
import           Data.Aeson                 as A
import           Data.Aeson.Encoding        (string)
import           Data.Aeson.Lens
import           Data.Aeson.TH
import           Data.Aeson.Types           (typeMismatch)
import           Data.Char
import           Data.Function              (on)
import           Data.List                  (intersperse, sortBy)
import           Data.Map                   as M
import           Data.Monoid
import           Data.Ord                   (comparing)
import           Data.Set                   as S
import           Data.String
import qualified Data.Text                  as T
import           Data.Text.Lens
import           Data.Time
import           Development.Shake
import           Development.Shake.Classes
import           Development.Shake.FilePath
import           GHC.Generics               (Generic)
import           Slick.Extra

import           Utils

-------------------------------------------------------------------------------
-- Core Data Types and Instances

-- | Represents the template dependencies of the index page
data IndexWrap =
  IndexWrap
    { posts         :: [Post]
    , postsFeatured :: [Post]
    } deriving (Generic, Show)

instance FromJSON IndexWrap
instance ToJSON IndexWrap

-- | A JSON serializable representation of a post's metadata
data Post =
  Post
    { title       :: String
    , authors     :: [T.Text]
    , date        :: UTCTime
    , image       :: Maybe String
    , featured    :: Bool
    , description :: String
--    , extDisqus    :: OptDisqus
--    , extFbComment :: OptFbComment
        -- internally predefined by Slick
    , url         :: String
    , content     :: String
    } deriving (Generic, Eq, Ord, Show)

instance FromJSON Post where
  parseJSON =
    withObject "metadata" $ \o -> do
      title       <- o .: "title"
      authors'    <- o .: "authors"
      date'       <- o .: "date"
      image       <- o .: "image"
      featured    <- o .: "featured"
      description <- o .: "description"
      url         <- o .: "url"
      content     <- o .: "content"

      let authors = T.splitOn "," authors'

      -- SB: for some reason we see doubled FromJSON -> ToJSON conversion, so
      --     for now we need to check for 2 possible date formats
      let dateM = parseTimeM True defaultTimeLocale "%Y-%m-%d" date'
      let date  =  case dateM of
                     Nothing -> parseTimeOrError True defaultTimeLocale "%B %e, %Y" date'
                     Just tm -> tm
      return $
        Post title authors date image featured description url content

instance ToJSON Post where
  toJSON (Post tl au dt im fe ds ul cn) =
    A.object
      [ "title"       A..= tl
      , "authors"     A..= T.intercalate "," au
      , "date"        A..= (renderToDay dt)
      , "image"       A..= im
      , "featured"    A..= fe
      , "description" A..= ds
      , "url"         A..= ul
      , "content"     A..= cn
      ]

data NewsWrap =
  NewsWrap
    { news :: [Post]
    } deriving (Generic, Show)

instance FromJSON NewsWrap
instance ToJSON NewsWrap

-- | Represents raw About page
data About =
  About
    { abrwTitle       :: String
    , abrwDescription :: String
    -- internally predefined by Slick
    , abrwUrl         :: String
    , abrwContent     :: String
    } deriving (Generic, Show)

-- use this to strip proj prefix
deriveJSON defaultOptions { fieldLabelModifier = dropPrefix 4 } ''About

-- | Represents About page
-- with additional data
data AboutWrap =
  AboutWrap
    { abTitle       :: String
    , abDescription :: String
    -- internally predefined by Slick
    , abUrl         :: String
    , abContent     :: String
    } deriving (Generic, Show)

deriveJSON defaultOptions { fieldLabelModifier = dropPrefix 2 } ''AboutWrap

--------------------------------------------------------------------------------

-- | We have to use unique constructors becasue Shake needs to create `Value` for each entity path
--   and to avoid Shake Oracle conflict. Used as a Shake Cache key to build a cache of post objects.

newtype AboutFilePath =
  AboutFilePath String
  deriving (Show, Eq,  Generic, Hashable, Binary, NFData)

newtype PostFilePath =
  PostFilePath String
  deriving (Show, Eq, Generic, Hashable, Binary, NFData)


{-# START_FILE app/Utils.hs #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TupleSections     #-}

module Utils
  ( renderToDay
  ) where

import           Control.Monad
import           Data.List                  (intersperse, sortBy)
import           Data.List                  as L (intersperse, sortBy, (\\))
import           Data.Ord                   (comparing)
import qualified Data.Text                  as T
import           Data.Time
import           Development.Shake
import           Development.Shake.FilePath
import           System.Directory
import           System.Directory.Extra     (listFilesRecursive, removeFile)
import           System.Environment

------------------------------------------------------------------------------
-- Helper functions

-- | Generalized sorting function
sortByM :: (Monad m, Ord k) => (a -> m k) -> [a] -> m [a]
sortByM f xs =
  liftM (Prelude.map fst . sortBy (comparing snd)) $ mapM (\x -> liftM (x,) (f x)) xs

-- | Render timestamp to the format required by page design
renderToDay :: FormatTime t => t -> String
renderToDay = formatTime defaultTimeLocale "%B %e, %Y"

{-# START_FILE README.md #-}
# {{name}}

{-# START_FILE LICENSE #-}
Copyright {{author-name}}{{^author-name}}Author name here{{/author-name}} (c) {{year}}{{^year}}2018{{/year}}

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of {{author-name}}{{^author-name}}Author name here{{/author-name}} nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
